package seng202.group2.model;

import seng202.group2.model.datacategories.DataCategory;
import seng202.group2.model.datacategories.ID;
import seng202.group2.model.datacategories.UnsupportedCategoryException;

import java.sql.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

/**
 * DataBaseManagementSystem. This controls the SQLite database and connects the data model together.
 * All SQL should be run through here.
 */
public class DBMS {

    private static final ActiveData activeData = new ActiveData();               //Active data class
    public static final String DATE_FORMAT = "dd'/'MM'/'yyyy hh':'mm':'ss a";     //Date format
    private static Connection conn;                                        //Database connection
    private static int idCounter = -1;                                     //Current item ID

    /**
     * Connect to the database
     */
    private static void getConnection() {
        try {
            //Create db connection
            Class.forName("org.sqlite.JDBC");
            conn = DriverManager.getConnection("jdbc:sqlite::memory:");

            //Initialize tables
            initialize();
        } catch (SQLException | ClassNotFoundException e) {
            System.out.println("Failed to get Connection DBMS:getConnection");
            //e.printStackTrace();
        }
    }

    /**
     * Create a table in the database
     * @param tableName Table name as a string
     */
    private static void createTable(String tableName) {
        try {
            System.out.println("Building " + tableName + " table");

            //Get the database and select the table
            Statement state = conn.createStatement();
            ResultSet result = state.executeQuery("SELECT name FROM sqlite_master WHERE type='table' AND tbl_name='" + tableName + "'");

            //Build table if it does not exist
            Statement state2 = conn.createStatement();
            state2.execute("CREATE TABLE IF NOT EXISTS " + tableName + "(id integer,"
                    + "caseNum string,"
                    + "date long,"
                    + "block string,"
                    + "IUCR string,"
                    + "primaryDescription string,"
                    + "secondaryDescription string,"
                    + "locationDescription string,"
                    + "arrest boolean,"
                    + "domestic boolean,"
                    + "beat short,"
                    + "ward short,"
                    + "fbiCode string,"
                    + "latitude float,"
                    + "longitude float,"
                    + "primary key(id));"
            );
        } catch (SQLException e) {
            System.out.println("Failed to create " + tableName + " table in database. DBMS:initialize");
        }
    }

    /**
     * Create the database and tables if they do not exist. Every computer will run this once, but you can also delete
     * the CrimeRecords.db file, and it will recreate it.
     */
    private static void initialize() {
        createTable("Records");
        createTable("ActiveRecords");
    }

    /**
     * Run a custom SQL query on the database
     *
     * @param query String representation of the SQL query
     * @return ResultSet containing results, NULL if failed.
     */
    public static ResultSet customQuery(String query) {
        if (conn == null) {
            getConnection();
        }

        try {
            Statement state = conn.createStatement();
            return state.executeQuery(query);
        } catch (SQLException e) {
            System.out.println("Could not run custom query. Query shown below. DBMS:customQuery");
            System.out.println(query);
            // There should be a better way to do this line. Or in fact it should be dealt with before here.
            // This line removes the last filter applied, so that if an added filter is invalid then it is removed from
            // the filters list
            // TODO make this integrated elsewhere.
            activeData.removeFilter(activeData.getFilters().get(activeData.getFilters().size() - 1));
            throw (new IllegalArgumentException("Invalid sql query"));
        }
    }

    /**
     * Converts a ResultSet containing one record into a CrimeRecord object
     *
     * @param record ResultSet containing a single record
     * @return CrimeRecord Generated by the function
     */
    private static CrimeRecord generateCrimeRecord(ResultSet record) {
        CrimeRecord crimeRecord = new CrimeRecord();

        //Set the data
        try {
            ResultSetMetaData metaData = record.getMetaData();
            int columnCount = metaData.getColumnCount();
            boolean isNull = false;

            // The column count starts from 1
            for (int i = 1; i <= columnCount; i++ ) {
                String name = metaData.getColumnName(i);

                //If the value is null, don't try to put it in.
                try {
                    String result = record.getString(name);
                    if (result == null) {
                        continue;
                    }
                } catch (NullPointerException e) {
                    continue;
                }

                //Else insert it into the CrimeData object
                switch (name) {
                    case "id" -> crimeRecord.setID(record.getInt("id"));
                    case "caseNum" -> crimeRecord.setCaseNum(record.getString("caseNum"));
                    case "date" -> {
                        //Convert long from db to Calendar
                        Calendar cal = Calendar.getInstance();
                        long epoch = Long.parseLong(record.getString("date"));
                        cal.setTimeInMillis(epoch * 1000L);
                        crimeRecord.setDate(cal);
                    }
                    case "block" -> crimeRecord.setBlock(record.getString("block"));
                    case "IUCR" -> crimeRecord.setIucr(record.getString("IUCR"));
                    case "primaryDescription" -> crimeRecord.setPrimaryDescription(record.getString("primaryDescription"));
                    case "secondaryDescription" -> crimeRecord.setSecondaryDescription(record.getString("secondaryDescription"));
                    case "locationDescription" -> crimeRecord.setLocationDescription(record.getString("locationDescription"));
                    case "arrest" -> crimeRecord.setArrest(record.getBoolean("arrest"));
                    case "domestic" -> crimeRecord.setDomestic(record.getBoolean("domestic"));
                    case "beat" -> crimeRecord.setBeat(record.getShort("beat"));
                    case "ward" -> crimeRecord.setWard(record.getShort("ward"));
                    case "fbiCode" -> crimeRecord.setFbiCode(record.getString("fbiCode"));
                    case "latitude" -> crimeRecord.setLatitude(record.getFloat("latitude"));
                    case "longitude" -> crimeRecord.setLongitude(record.getFloat("longitude"));
                }
            }
        } catch (SQLException e) {
            e.getStackTrace();
        }

        return crimeRecord;
    }

    /**
     * Gets a record from Records table by ID.
     *
     * @param id Integer representing the ID of the record
     * @return CrimeRecord retrieved from Records. NULL if the record does not exist
     */
    public static CrimeRecord getRecord(int id) {
        if (conn == null) {
            getConnection();
        }

        try {
            //Get record
            Statement state = conn.createStatement();
            ResultSet result = state.executeQuery("SELECT * FROM Records WHERE id =" + id);
            return generateCrimeRecord(result);
        } catch (SQLException e) {
            System.out.println("Could not retrieve record with ID: " + id + " from Records table. DBMS:getRecord");
        }

        return null;
    }


    /**
     * Get multiple records from Records table as an ArrayList.
     *
     * @return ArrayList of CrimeRecords.
     */
    public static ArrayList<CrimeRecord> getRecords(int min, int limit) {
        ArrayList<CrimeRecord> records = new ArrayList<>();
        ResultSet results;

        if (conn == null) {
            getConnection();
        }

        try {
            //Select records from Records
            Statement state = conn.createStatement();
            results = state.executeQuery("SELECT * FROM Records LIMIT " + limit + " OFFSET " + min);

            //Generate and add the records to the records ArrayList
            while (results.next()) {
                records.add(generateCrimeRecord(results));
            }
        } catch (SQLException e) {
            System.out.println("Could not retrieve records from Records table. DBMS:getRecords");
            //e.printStackTrace();
        }

        return records;
    }

    /**
     * Get multiple records from ActiveRecords table as an ArrayList.
     *
     * @return ArrayList of CrimeRecords.
     */
    public static ArrayList<CrimeRecord> getActiveRecords(int min, int limit, String order) {
        ArrayList<CrimeRecord> records = new ArrayList<>();
        ResultSet results;

        if (conn == null) {
            getConnection();
        }

        try {
            //Select records from Records
            Statement state = conn.createStatement();

            if (activeData.getFilters().size() > 0 || activeData.getSearchPattern().length() > 1) {
                results = state.executeQuery("SELECT * FROM ActiveRecords " + order + " LIMIT " + limit + " OFFSET " + min);
            } else {
                results = state.executeQuery("SELECT * FROM Records " + order + " LIMIT " + limit + " OFFSET " + min);
            }


            //Generate and add the records to the records ArrayList
            while (results.next()) {
                records.add(generateCrimeRecord(results));
            }
        } catch (SQLException e) {
            System.out.println("Could not retrieve records from ActiveRecords table. DBMS:getActiveRecords");
            //e.printStackTrace();
        }

        return records;
    }

    /**
     * Gets all records in the database.
     *
     * @return An ArrayList of all crime records stored in the database.
     */
    public static ArrayList<CrimeRecord> getAllRecords() {
        if (conn == null) {
            getConnection();
        }

        ResultSet results;
        try {
            Statement state = conn.createStatement();
            results = state.executeQuery("SELECT * FROM Records;");
        } catch (SQLException e) {
            System.out.println("Could not get all records from the database. DBMS:getAllRecords");
            //e.printStackTrace();
            return null;
        }

        //Generate and add the records to the records ArrayList
        ArrayList<CrimeRecord> records = new ArrayList<>();
        while (true) {
            try {
                if (!results.next()) break;
                records.add(generateCrimeRecord(results));
            } catch (SQLException e) {
                System.out.println("Could not retrieve record from record table.");
                e.printStackTrace();
                continue;
            }
        }

        return records;
    }

    /**
     * Adds a record to the database. Update the observers if desired
     *
     * @param record -- CrimeRecord to add. This CrimeRecord does not need an id assigned
     * @param update -- If true, the ActiveData will be updated
     */
    public static void addRecord(CrimeRecord record, boolean update) {
        if (conn == null) {
            getConnection();
        }

        //If we don't already have a counter
        if (idCounter == -1) {
            //Find the current ID
            try {
                Statement maxID = conn.createStatement();
                ResultSet res = maxID.executeQuery("SELECT MAX(id) as max FROM Records;");
                idCounter = res.getInt("max") + 1;
            } catch (SQLException e) {
                System.out.println("Could not find the MAX ID in the Records table. DBMS:addRecord");
            }
        }


        // Generate insert statement for the CrimeRecord instance
        SQLInsertStatement state = new SQLInsertStatement("Records");
        for (DataCategory category : DataCategory.getCategories()) {
            try {
                state.setValue(category.getSQL(), category.getRecordCategory(record).getValueString(), category.getValueType() == String.class);
            } catch (NullPointerException e) {
                state.setValue(category.getSQL(), null, false);
            }
        }
        state.setValue(ID.getInstance().getSQL(), Integer.toString(idCounter++), false);

        try {
            //Insert into the database
            Statement insert = conn.createStatement();
            insert.execute(state.getStatement());

            //Update observers
            if (update) {
                activeData.updateActiveData();
            }
        } catch (SQLException e) {
            System.out.println("Could not insert record into Records table: " + e.toString());
        }
    }

    /**
     * Updaet record in database. Updating based on records ID
     *
     * @param record Record holding all the new data to set
     */
    public static void updateRecord(CrimeRecord record) {
        if (conn == null) {
            getConnection();
        }

        // Generate update statement
        String updateRecordsString = "UPDATE Records";
        String updateActiveRecordsString = "UPDATE ActiveRecords";
        String updateString = "";

        boolean first = true;
        for (DataCategory category : DataCategory.getCategories()) {
            //Skip ID
            if (category.getRecordCategory(record) instanceof ID) {
                continue;
            }

            //Add category to string
            try {
                String value = SQLInsertStatement.formatValue(category.getSQL(), category.getRecordCategory(record).getValueString(), category.getValueType() == String.class);
                updateString += (first? " SET " : ", ") + category.getSQL() + " = " + value;
            } catch (NullPointerException e) {
                continue;
            }
            if (first) first = false;
        }

        updateRecordsString += updateString + " WHERE id = " + record.getID();
        updateActiveRecordsString += updateString + " WHERE id = " + record.getID();

        try {
            //Update in the database
            Statement updateRecords = conn.createStatement();
            updateRecords.execute(updateRecordsString);

            Statement updateActiveRecords = conn.createStatement();
            updateActiveRecords.execute(updateActiveRecordsString);

            //Update observers
            activeData.updateActiveData();
        } catch (SQLException e) {
            System.out.println("Could not update record: " + e.toString());
            System.out.println(updateString);
        }
    }

    /**
     * Add an ArrayList of CrimeRecords to the database.
     *
     * @param records -- ArrayList of CrimeRecords to add to the database
     */
    public static void addRecords(List<CrimeRecord> records) {
        for (CrimeRecord record : records) {
            addRecord(record, false);
        }
    }

    /**
     * Update the ActiveDatabase with records from Records that match the given IDs.
     *
     * @param IDs -- ArrayList of IDs to match
     */
    public static void updateActiveDatabase(ArrayList<Integer> IDs) {
        if (conn == null) {
            getConnection();
        }

        //Clear the database
        try {
            Statement deleteStatement = conn.createStatement();
            deleteStatement.execute("DELETE FROM ActiveRecords;");

        } catch (SQLException e) {
            System.out.println("Could not clear ActiveRecords. DBMS:updateActiveDatabase");
        }

        //Copy data in blocks to reduce string size
        final int blockSize = 200;
        final int size = IDs.size();
        int start = 0;
        int end = Math.min(size, blockSize);

        while (start < size) {
            //Create copy string
            StringBuilder conditions = new StringBuilder("WHERE id IN (");
            boolean first = true;

            for (int i=start; i < end; i++) {
                if (first) {
                    conditions.append(Integer.toString(IDs.get(i)));
                    first = false;
                }
                else {
                    conditions.append(",").append(Integer.toString(IDs.get(i)));
                }
            }
            conditions.append(");");

            try {
                //Execute
                Statement getActive = conn.createStatement();
                getActive.execute("INSERT INTO ActiveRecords SELECT * FROM Records " + conditions);
            } catch (SQLException e) {
                System.out.println("Could not copy block to ActiveRecords. DBMS:updateActiveDatabase\n");
            }

            //Update block count
            start = end;
            end = Math.min(end + blockSize, size);

            System.out.print("\rAdded " + start + " records to activeRecords database.");
        }
    }

    /**
     * Delete record from database by ID
     *
     * @param id Integer ID of the record to delete
     */
    public static void deleteRecord(int id) {
        if (conn == null) {
            getConnection();
        }

        try {
            Statement state = conn.createStatement();
            state.execute("DELETE FROM Records WHERE id =" + id);
            Statement state2 = conn.createStatement();
            state2.execute("DELETE FROM ActiveRecords WHERE id =" + id);
        } catch (SQLException e) {
            System.out.println("Could not delete record with ID: " + id + " from database. DBMS:deleteRecord");
        }
    }

    /**
     * Deletes all the selected records from the database by calling {@link DBMS#deleteRecord(int)}
     * on each of them. This method sets the selection to empty after deleting all the items, and then it
     * updates the observers.
     */
    public static void deleteSelectedRecords() {
        for (Integer id: activeData.getSelectedRecords()) {
            deleteRecord(id);
        }
        activeData.clearSelection();
        activeData.updateActiveRecords();
        activeData.updateActiveData();
    }

    /**
     * Remove all records from the database and reset ID counter
     */
    public static void clearDB() {
        if (conn == null) {
            getConnection();
        }

        try {
            //Delete Records
            Statement state = conn.createStatement();
            state.execute("DELETE FROM Records;");
            Statement state2 = conn.createStatement();
            state2.execute("DELETE FROM ActiveRecords;");
        } catch (SQLException e) {
            System.out.println("Could not delete all records from database. DBMS:clearDB");
        }

        //Reset counter
        idCounter = -1;
    }

    /**
     * Find the number of records in the Records table
     *
     * @return Number of records in Record table. Returns -1 on failure.
     */
    public static int getRecordsSize() {
        if (conn == null) {
            getConnection();
        }

        try {
            Statement state = conn.createStatement();
            ResultSet res = state.executeQuery("SELECT COUNT(DISTINCT id) as total FROM Records;");

            res.next();
            return res.getInt("total");
        } catch (SQLException e) {
            System.out.println("Failed to get size of Record table. DBMS:getRecordsSize");
        }

        return -1;
    }

    /**
     * Find the number of records in the ActiveRecords table
     *
     * @return Number of records in ActiveRecords table. Returns -1 on failure.
     */
    public static int getActiveRecordsSize() {
        if (conn == null) {
            getConnection();
        }

        try {
            if ((activeData.getFilters().size() <= 0))
                return getRecordsSize();

            Statement state = conn.createStatement();
            ResultSet res = state.executeQuery("SELECT COUNT(DISTINCT id) as total FROM ActiveRecords;");

            res.next();
            return res.getInt("total");
        } catch (SQLException e) {
            System.out.println("Failed to get size of ActiveRecord table. DBMS:getActiveRecordsSize");
        }

        return -1;
    }

    /**
     * Get ActiveData object associated with this DBMS
     */
    public static ActiveData getActiveData() {
        return activeData;
    }
}
