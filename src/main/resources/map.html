<!DOCTYPE html>
<html>

<head>
    <title>Map</title>
    <style>
    	
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            height: 100%;
        }
        .center {
          text-align: center;
        }
    </style>
</head>

<body>
<div id="map"></div>

<script>
    //Map controls
    let streetNamesEnabled = true;
    let animationsEnabled = true;
    let onlySelected = false;

    const fixedStyles = [
        {
            featureType: "poi",
            elementType: "labels",
            stylers: [
                { visibility: "off" }
            ]
        },
        {
            featureType: 'transit',
            elementType: 'labels',
            stylers: [{visibility: 'off'}]
        },
    ];

    let styles = [];

    let mapOptions = {
        zoom: 1,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: false,
        scaleControl: true,        
        styles: styles,
        
    };

    //Map objects
    let map;
    let heatmap = null;
    let infoWindow = null;
    let line = null;
    
    
    changeCursor();
    
        

    //Markers
    let markers = [];
    let markersSelected = [];
    let markersEnabled = true;

    //Heatmap
    let heatMapData = []
    let heatMapEnabled = false;
    let heatMapRadius = 50;
    
    
    /**
	* Changes the cursor to 'wait' when map is being loaded, then cursor is reverted back to default.
	*/
	function changeCursor() {
  		document.getElementById("map").style.cursor = "wait";
	}
    



	
	

    /**
    * Creates the google.maps.Map to be rendered on the html map div element with optional Map options.
    */
    function initMap() {
        let initialMapOptions = {
            zoom: 1,
            mapTypeControl: true,
            streetViewControl: false,
            fullscreenControl: false,
            scaleControl: true,
            styles: fixedStyles,
            
            
        };
        
        
        map = new google.maps.Map(document.getElementById("map"), initialMapOptions);
        
        

        heatmap = new google.maps.visualization.HeatmapLayer({
            data: heatMapData
            
        });
        
    }
    
    
    

    /**
     * Change the heatmap raduus variable and update
     * @param rad Radius to use
     */
    function changeRadius(rad) {
        heatMapRadius = rad;
        updateHeatMap();
    }

    /**
     * Toggle only selected markers on or off
     */
    function toggleOnlySelected() {
        onlySelected = !onlySelected;

        heatMapData = [];
        if (onlySelected) {
            markers.forEach(function (marker) {
                marker.setMap(null);
            });
            markersSelected.forEach(function (marker) {
                if (markersEnabled) marker.setMap(map);
                heatMapData.push(marker.position);
            });
        } else {
            markers.forEach(function (marker) {
                if (markersEnabled) marker.setMap(map);
                heatMapData.push(marker.position);
            });
        }

        updateHeatMap()
    }

    /**
     * Toggle markersEnabled true or not false, set the markers accordingly
     */
    function toggleMarkers() {
        markersEnabled = !markersEnabled;

        if (markersEnabled) {        	
            markers.forEach(function (marker) {
                if (onlySelected) {
                    if (marker.selected) marker.setMap(map);
                } else {
                    marker.setMap(map);
                }
            });
        } else {
            markers.forEach(function (marker) {
                marker.setMap(null);
            });
        }
    }

    /**
     * Toggle heatMapEnabled true of false, then update
     */
    function toggleHeatmap() {
        heatMapEnabled = !heatMapEnabled;

        if (heatMapEnabled) {
            updateHeatMap();
        } else {
            heatmap.setMap(null);
        }
    }

    function toggleStreetNames() {
        streetNamesEnabled = !streetNamesEnabled;

        //clear styles
        while (styles.length > 0)
            styles.pop();

        //Add fixed styles
        styles = styles.concat(fixedStyles);

        //Add street name style
        if (streetNamesEnabled) {
            styles.push({
                featureType: 'road',
                elementType: 'labels',
                stylers: [{visibility: 'on'}]
            });
        } else {
            styles.push({
                featureType: 'road',
                elementType: 'labels',
                stylers: [{visibility: 'off'}]
            });
        }

        mapOptions = {
            zoom: map.zoom,
            center: map.center,
            mapTypeControl: map.mapTypeControl,
            streetViewControl: map.streetViewControl,
            fullscreenControl: map.fullscreenControl,
            scaleControl: map.scaleControl,
            styles: styles,
        };
        map.setOptions(mapOptions);
    }

    function toggleAnimations() {
        animationsEnabled = !animationsEnabled;

        if (animationsEnabled) {
            markersSelected.forEach((marker) => {if (marker.selected) (marker.setAnimation(google.maps.Animation.BOUNCE))})
        } else {
            markersSelected.forEach((marker) => {if (marker.selected) (marker.setAnimation(null))})
        }
    }

    /**
     * Update the heatmap with new data, depending on heatMapEnabled
     */
    function updateHeatMap() {
        heatmap.setMap(null);
        if (heatMapEnabled) {
            heatmap = new google.maps.visualization.HeatmapLayer({
                data: heatMapData,
                radius: heatMapRadius,
            });
            heatmap.setMap(map);
        }
    }

    /**
     * Creates a new google.maps.Marker object for the given recordId, sets its position, and displays it on the map.
     * @param recordId  The id of the CrimeRecord to which the added marker corresponds.
     * @param latitude  The latitudinal location at which the crime took place.
     * @param longitude The longitudinal location at which the crime took place.
     */
    function addMarker(recordId, latitude, longitude, color) {
        //Create marker
        var marker = new google.maps.Marker({
            position: new google.maps.LatLng(latitude, longitude),
            animation: (color == "blue" && animationsEnabled) ? google.maps.Animation.BOUNCE : null,
            selected: (color == "blue"),
            zIndex: (color == "blue") ? 2 : 1,
            crimeId: recordId,
            optimized: true,
            icon: {
                url: "http://maps.google.com/mapfiles/ms/icons/" + color + "-dot.png"
            }
        });

        //Create event listener
        google.maps.event.addListener(marker, "click", function(e) {
            toggleMarkerSelected(marker);
        });

        //Add to map and list
        
        markers.push(marker);
        if (marker.selected) markersSelected.push(marker);

        if (onlySelected) {
            if (marker.selected && markersEnabled) marker.setMap(map);
            if (marker.selected) heatMapData.push(new google.maps.LatLng(latitude, longitude));
        } else {
            if (markersEnabled) marker.setMap(map);
            heatMapData.push(new google.maps.LatLng(latitude, longitude));
        }

        updateHeatMap();
    }

    /**
     * Removes a marker corresponding to a specific CrimeRecord from the map.
     * @param recordId  The id of the CrimeRecord whose marker is to be removed.
     */
    function removeMarker(recordId) {
        let marker = findMarker(recordId);

        marker.setMap(null);
        let i = markers.indexOf(marker);
        markers = markers.splice(i,i);

        //Remove from heatmap
        for (let i=0; i < heatMapData.length; i++) {
            if (heatMapData[i].lat == marker.position.lat && heatMapData[i].lng == marker.position.lng) {
                heatMapData = heatMapData.splice(i,i);
                break;
            }
        }

        updateHeatMap();
    }

    /**
     * Find a marker in the marker array by ID
     * Null if not found
     *
     * @param id ID of record to find
     * @returns {null|Marker} Marker with given ID, or null if not found
     */
    function findMarker(id) {
        //Find marker
        for (let i = 0; i < markers.length; i++) {
            if (markers[i].crimeId == id) {
                return markers[i];
            }
        }

        return null
    }

    /**
     * Deselect all markers
     */
    function deselectAllMarkers() {
        for (let i=0; i < markers.length; i++) {
            if (markers[i].selected) {
                markers[i].setZIndex(1);
                markers[i].setAnimation(null);
                markers[i].selected = false;
                markers[i].setIcon({url: "http://maps.google.com/mapfiles/ms/icons/" + "red" + "-dot.png"});

                markersSelected = markersSelected.splice(i,i);

                if (onlySelected && markersEnabled) {
                    markers[i].setMap(null);
                    let x = heatMapData.indexOf(markers[i].position);
                    heatMapData = heatMapData.splice(x,x);
                    updateHeatMap()
                }
            }
        }
    }

    /**
     * Deselect marker by ID
     *
     * @param id ID of marker to deselect
     */
    function deselectMarker(id) {
        //Find marker
        let marker = findMarker(id);

        //Deselect if not null
        if (marker != null) {
            marker.setZIndex(1);
            marker.setAnimation(null);
            marker.selected = false;
            marker.setIcon({url: "http://maps.google.com/mapfiles/ms/icons/" + "red" + "-dot.png"});

            let x = markersSelected.indexOf(markers);
            markersSelected = markersSelected.splice(x,x);

            if (onlySelected && markersEnabled) {
                marker.setMap(null);
                let x = heatMapData.indexOf(markers[i].position);
                heatMapData = heatMapData.splice(x,x);

                updateHeatMap()
            }
        }
    }

    /**
     * Select marker by ID
     *
     * @param id ID of marker to select
     */
    function selectMarker(id) {
        //Find marker
        let marker = findMarker(id);

        //Select if not null
        if (marker != null) {
            marker.setZIndex(2);
            if (animationsEnabled) marker.setAnimation(google.maps.Animation.BOUNCE);
            marker.selected = true;
            marker.setIcon({url: "http://maps.google.com/mapfiles/ms/icons/" + "blue" + "-dot.png"});
            markersSelected.push(marker);
        }

        if (onlySelected && markersEnabled) {
            marker.setMap(map);
            heatMapData.push(marker.position);

            updateHeatMap()
        }
    }

    /**
     * Toggle selection of marker on click, toggle info window
     *
     * @param marker Marker to toggle
     */
    function toggleMarkerSelected(marker) {
        if (marker.selected) {
            //Close info window
            if (infoWindow != null) infoWindow.close();

            //Update active data selection
            app.deselectRecord(marker.crimeId);
        } else {
            //Open info window
            const contentString = '<div id="content" class="center">' +
                                '<div id="siteNotice">' + '</div>' +
                                '<h1 id="firstHeading" class="firstHeading" align="center" >Crime ID: ' + marker.crimeId + '</h1>' +
                                '<div id="bodyContent" class="center"><h3>' + marker.position + '</h3></div>' +
                                '</div>';

            if (infoWindow != null) infoWindow.close();
            infoWindow = new google.maps.InfoWindow();
            infoWindow.setContent(contentString); //"<div style ='width:200px; min-height:40px'>" + marker.position + "</div>");
            infoWindow.open(map, marker);

            map.panTo(marker.getPosition());
            app.setDetails(marker.crimeId);

            //Update active data selection
            app.selectRecord(marker.crimeId);
        }
    }

    /**
     * Removes all markers from the map.
     */
    function clearMarkers() {
        for (let i = 0; i < markers.length; i++) {
            markers[i].setMap(null);
        }
        markers = [];
        heatMapData = [];

        updateHeatMap()
    }

    /**
    * Sets the boundary of the map to contain all the markers to be seen.
    * The map centered and the zoom is adjusted based on the markers and their positions.
    * The best possible view of Google Map is then shown to the user
    */
    function setBounds() {
        var bounds = new google.maps.LatLngBounds();

        for (let i = 0; i < markers.length; i++) {
            if (onlySelected || markersSelected.length >= 1) {
                if (markers[i].selected) bounds.extend(markers[i].position)
            } else {
                bounds.extend(markers[i].position)
            }
        }
        map.setCenter(bounds.getCenter());
        map.fitBounds(bounds);
    }

    /**
     * Draw a line between two markers
     */
    function drawLine() {
        if (markersSelected.length == 2) {
            line = new google.maps.Polyline({
                path: [markersSelected[0].position, markersSelected[1].position],
                strokeColor: "#FF0000",
                strokeOpacity: 1.0,
                strokeWeight: 3,
                geodesic: true,
                map: map
            });
            line.setMap(map);

            const contentString = '<div id="content" class="center">' +
                '<div id="siteNotice">' + '</div>' +
                '<h1 id="firstHeading" class="firstHeading" align="center" >Distance: ' + haversine_distance(markersSelected[0], markersSelected[1]).toFixed(2) + 'km</h1>' +
                '</div>';

            if (infoWindow != null) infoWindow.close();
            infoWindow = new google.maps.InfoWindow();
            infoWindow.setContent(contentString);
            infoWindow.open(map,markersSelected[0]);
        } else {
            if (line != null) line.setMap(null);
        }
    }

    /**
     * Distance between two points
     * @param mk1 Marker 1
     * @param mk2 Marker 2
     * @returns {number} Distance between two points
     */
    function haversine_distance(mk1, mk2) {
        const R = 3958.8; // Radius of the Earth in miles
        let rlat1 = mk1.position.lat() * (Math.PI/180); // Convert degrees to radians
        let rlat2 = mk2.position.lat() * (Math.PI/180); // Convert degrees to radians
        let difflat = rlat2-rlat1; // Radian difference (latitudes)
        let difflon = (mk2.position.lng()-mk1.position.lng()) * (Math.PI/180); // Radian difference (longitudes)

        let d = 2 * R * Math.asin(Math.sqrt(Math.sin(difflat/2)*Math.sin(difflat/2)+Math.cos(rlat1)*Math.cos(rlat2)*Math.sin(difflon/2)*Math.sin(difflon/2)));
        return d;
    }

</script>

<!-- Async script executes immediately and must be after any DOM elements used in callback. -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAka2EHrmJfR-AU7CkIJFzplWzG2Z-x_qo&callback=initMap&libraries=visualization&v=weekly" async></script>

</body>
</html>
